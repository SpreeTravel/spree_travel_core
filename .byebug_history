exit
self.save
self.errors
c
self.errors
c
exit
c
a = create(:rate)
c
self.rate_option_values
self.errors
c
self.errors
c
self.errors
self.rate_option_values
self.valid?
c
rate.end_date >= start_date && end_date >= rate.start_date
c
start_date
c
Spree::OptionValue.find_by_name('start_date')
start_date
c
start_date
c
Spree::OptionValue.find_by_name('start_date')
start_date
start_date.id
start_date
rate_option_values
c
rate_option_values
rate_option_values.select {|e| e.option_value_id == start_date.id }
c
start_date
c
Spree::OptionValue.count
Spree::OptionValue.last
start_date
c
Spree::OptionValue.last
Spree::OptionValue.count
Spree::OptionValue.find_by_name('start_date')
start_date
rate_option_values
c
context.errors.messages[:end_date]
c
pickup_date.option_value
pickup_date_option_value.option_type
pickup_date_option_value
pickup_date.option_value
pickup_date
c
context_option_values.last.option_value
c
context_option_values.last.option_value
context_option_values.first.option_value
context_option_values
pickup_date
context_option_values.select {|e| e.option_value_id == pickup_date.id }
c
context_option_values.first.option_value
pickup_date
context_option_values
context_option_values.select {|e| e.option_value_id == pickup_date.id }
context_option_values.select {|e| e.option_value_id == pickup_date.id }.first.value
pickup_date
c
context_option_values
c
rate2.errors.messages[:overlaps]
c
exit
c
Spree::OptionType.all
Spree::OptionType
Spree::OptionType.find_by_name('end_date')
Spree::OptionType.find_by_name(:end_date)
option_type
n
option_type
s
c
n
option_type
c
rates.first.rate_option_values
c
Spree::OptionType.all
Spree::OptionType.count
Spree::RateOptionValue.count
Spree::RateOptionValue.last
rates.first.rate_option_values
rates.first.start_date
rates
variant_id
c
rate2
c
self
variant_id
rates
c
self
c
self
rates
c
rate2.errors.messages
rate2.errors.messages[:overlaps]
c
rate.errors.messages
rate.errors.messages[:overlaps_with_other]
c
rate.errors.messages
rate.errors
n
rate.errors
c
start_date.to_date
end_date.to_date
end_date.to_date <= start_date.to_date
start_date
n
rate_option_values
c
rate_option_values
c
rate_option_values
c
Spree::Pax.new(line_item: line_item)
Spree::Pax
Spree::Pax.new
Pax.new
line_item.paxes
line_item.paxes.new
line_item.paxes
line_item
count
c
line_item.context_id
line_item
line_item.context
line_item.context.nil?
line_item
c
count
n
c
line_items
c
line_items
c
n
s
c
line_items
c
n
s
c
n
c
Spree::Api::V1::LineItemsController.line_item_options
c
Spree::Api::V1::LineItemsController.line_item_options
Spree::Api::V1::LineItemsController.line_item_options.shift
Spree::Api::V1::LineItemsController.line_item_options.class
Spree::Api::V1::LineItemsController.line_item_options
c
params[:line_item]
line_items_attributes
params.require(:line_item)
params
c
rate
context
c
context
c
context
c
respond_with(@line_item, status: 201, default_template: :show)
@line_item
c
json_response
c
line_item.nil?
n
c
n
line_item
n
options
Spree::PermittedAttributes.line_item_attributes
PermittedAttributes.line_item_attributes
c
context
c
Spree::Dependencies.cart_add_item_service.constantize
c
n
s
n
c
n
s
n
s
klass
s
n
s
n
s
n
s
n
s
n
s
c
n
s
n
s
c
line_item
c
Spree::StockLocation.count
Spree::StockLocation.any?
c
line_item
line_item.variant
line_item.variant.stock_items
c
self.variant.stock_items
c
self.variant.stock_items
c
self.variant.stock_items
self.errors
self.valid?
c
self
errors
n
c
self
c
self
