c
rate_option_values.first.respond_to?(:price)
rate_option_values.first.respond_to(:price)
rate_option_values
s
option_type
n
s
c
context_or_rate_option_value
n
c
context_or_rate_option_value.price
context_or_rate_option_value.price.format
context_or_rate_option_value.price
context_or_rate_option_value.save
context_or_rate_option_value
n
value
n
context_or_rate_option_value
n
rate_option_values
rate_option_values.first.option_value.option_type
rate_option_values.first.option_value
c
rate_option_values.first.option_value.option_type
rate_option_values.first.option_value
rate_option_values
s
n
s
c
context_or_rate_option_value
n
c
      rate_option_values.includes(option_value: :option_type).find { |rov| rov.option_value&.option_type_id == option_type.id}
s
n
s
c
option_type.id
self.rate_option_values.first.option_value.option_type_id
self.rate_option_values.first.option_value
self.rate_option_values.option_value
self.rate_option_values
self
find_existing_option_value(option_type)
option_type
n
s
find_option_value(option_type)
c
option_type
find_option_value(option_type)
context_or_rate_option_value
n
rate_option_values.first.option_value.option_type_id == option_type.id
rate_option_values.first.option_value.option_type_id
option_type
rate_option_values.first.option_value.option_type
rate_option_values.first.option_value
option_type
rate_option_values.first
rate_option_values
s
n
option_type
s
c
context_or_rate_option_value
option_type
n
c
bt
down
up
attr
c
e
n
attributes
json_response
attributes
c
response.status
respnse.status
flash[:error]
c
@product.product_type.present?
params
c
params[:product_type].nil?
@product.product_type.present?
@product.product_type.present? && params[:product_type].nil?
params
c
params
paras
@product.product_type.present? && params[:product_type].nil?
c
response.body
flash[:error]
c
flash[:error]
flash
response
response.body
c
controller.permitted_checkout_attributes.last[ controller.permitted_checkout_attributes.last.keys.last]
controller.permitted_checkout_attributes.last
controller.permitted_checkout_attributes.last.last
controller.permitted_checkout_attributes.last
controller.permitted_checkout_attributes.last.last
controller.permitted_checkout_attributes.last
controller.permitted_checkout_attributes.last.keys
controller.permitted_checkout_attributes.last.class
controller.permitted_checkout_attributes.last
controller.permitted_checkout_attributes.last[0]
controller.permitted_checkout_attributes.last[-1]
controller.permitted_checkout_attributes.last
controller.permitted_checkout_attributes.include?(:line_items_attributes=>[:id, :variant_id, :quantity, :paxes, {:paxes_attributes=>[:id, :first_name, :last_name]}])
controller.permitted_checkout_attributes.include?(:line_items_attributes)
controller.permitted_checkout_attributes
controller.permitted_checkout_attributes.include?(:email)
controller.permitted_checkout_attributes.includes?(:email)
controller.permitted_checkout_attributes.include?(:line_items_attributes)
controller.permitted_checkout_attributes.includes?(:line_items_attributes)
controller.permitted_checkout_attributes
controller.permitted_checkout_attributes[:line_items_attributes]
controller.permitted_line_item_attributes
controller.permitted_checkout_attributes
controller.permitted_attributes
c
calculator.name
context.context_option_values
context
c
Spree::Product.count
c
exit
Spree::Product.last
Spree::Product.first
Spree::Product.count
Spree::Variant.all
Spree::Variant.count
c
cc
c
rate
n
exit
c
params
params['rate_id']
params[rate_id']
params[:rate_id]
Spree::Rate.find_by(id: 1)
Spree::Rate.find_by(id: params[:rate_id])
params
Spree::Rate.last
Spree::Variant.count
exit
exitt
c
Spree::Variant.count
Spree::Rate.last
Spree::Rate.count
c
result
n
context.context_option_values
context
n
rate
n
params
c
order.id.to_s
order.id.to_
expect(json_response['data']).to have_id(order.id.to_s)
expect(json_response['data']).to be_present
json_response['data']
c
json_response({})
require 'spree/api/testing_support/helpers'
 require 'spree/testing_support/helpers'
c
require 'spree/api/testing_support/v2/current_order'
 require 'spree/testing_support/authorization_helpers'
c
Rails.application.instance_variable_get(:"@_all_autoload_paths")
 require 'spree/testing_support/authorization_helpers'
c
require 'spree/testing_support/authorization_helpers'
c
require 'spree/api/testing_support/setup'
require 'spree/api/testing_support/v2/base'
require 'spree/api/testing_support/v2/current_order'
require 'spree/api/testing_support/v2/base'
require 'spree/api/testing_support/caching'
require 'spree/api/testing_support/helpers'
require 'spree/api/testing_support/setup'
require 'spree/testing_support/authorization_helpers'
c
require 'ffaker'
require 'spree/testing_support/capybara_ext'
require 'spree/testing_support/'
require 'spree/testing_support'
require 'spree'
require 'spree/testing_support/capybara_ext'
require 'spree/api/testing_support/helpers'
c
attr
n
attr
c
variant.product_type.present?
c
variant.product_type.present?
c
variant.product_type.present?
c
n
c
allow_any_instance_of(Spree::Variant).to receive(:product).and_return(@travel_product)
variant
variant.product
variant.product.product_type.present?
c
variant.product_type.present?
n
c
variant.product_type
n
c
variant.product
variant.product_type
variant.product_type.present?
c
n
c
variant.product
variant.product_type
variant.product_type.present?
n
variant
c
Spree::Stock::Quantifier.new(line_item.variant).c
Spree::Stock::Quantifier.new(line_item.variant)
s
n
 item_available?(line_item, quantity)
n
c
a.errors
